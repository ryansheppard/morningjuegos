// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: stats.sql

package database

import (
	"context"
	"database/sql"
)

const createHole = `-- name: CreateHole :one
INSERT INTO hole (round_id, color, strokes, hole_number, inserted_by) VALUES ($1, $2, $3, $4, $5) RETURNING id, round_id, hole_number, color, strokes, inserted_at, inserted_by
`

type CreateHoleParams struct {
	RoundID    int32
	Color      string
	Strokes    int32
	HoleNumber int32
	InsertedBy string
}

// Hole Queries
func (q *Queries) CreateHole(ctx context.Context, arg CreateHoleParams) (Hole, error) {
	row := q.db.QueryRowContext(ctx, createHole,
		arg.RoundID,
		arg.Color,
		arg.Strokes,
		arg.HoleNumber,
		arg.InsertedBy,
	)
	var i Hole
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.HoleNumber,
		&i.Color,
		&i.Strokes,
		&i.InsertedAt,
		&i.InsertedBy,
	)
	return i, err
}

const getBestRounds = `-- name: GetBestRounds :many
SELECT CAST(MIN(total_strokes) AS INTEGER) AS total_strokes, player_id
FROM round
WHERE tournament_id = $1
AND first_round = TRUE
GROUP BY player_id
ORDER BY total_strokes ASC
`

type GetBestRoundsRow struct {
	TotalStrokes int32
	PlayerID     int64
}

func (q *Queries) GetBestRounds(ctx context.Context, tournamentID int32) ([]GetBestRoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBestRounds, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBestRoundsRow
	for rows.Next() {
		var i GetBestRoundsRow
		if err := rows.Scan(&i.TotalStrokes, &i.PlayerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHardestHole = `-- name: GetHardestHole :one
SELECT AVG(strokes) AS strokes, color
FROM hole 
LEFT JOIN round ON hole.round_id = round.id
WHERE round.tournament_id = $1
AND round.first_round = TRUE
GROUP BY color
ORDER BY strokes DESC
LIMIT 1
`

type GetHardestHoleRow struct {
	Strokes float64
	Color   string
}

func (q *Queries) GetHardestHole(ctx context.Context, tournamentID int32) (GetHardestHoleRow, error) {
	row := q.db.QueryRowContext(ctx, getHardestHole, tournamentID)
	var i GetHardestHoleRow
	err := row.Scan(&i.Strokes, &i.Color)
	return i, err
}

const getHoleInOneLeaders = `-- name: GetHoleInOneLeaders :many
SELECT COUNT(*) AS count, round.player_id
FROM hole
LEFT JOIN round ON hole.round_id = round.id
WHERE round.tournament_id = $1
AND round.first_round = TRUE
AND round.player_id IS NOT NULL
AND hole.strokes = 1
GROUP BY round.player_id
ORDER BY count DESC
`

type GetHoleInOneLeadersRow struct {
	Count    int64
	PlayerID sql.NullInt64
}

func (q *Queries) GetHoleInOneLeaders(ctx context.Context, tournamentID int32) ([]GetHoleInOneLeadersRow, error) {
	rows, err := q.db.QueryContext(ctx, getHoleInOneLeaders, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoleInOneLeadersRow
	for rows.Next() {
		var i GetHoleInOneLeadersRow
		if err := rows.Scan(&i.Count, &i.PlayerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostCommonHoleForNumber = `-- name: GetMostCommonHoleForNumber :one
SELECT COUNT(color) AS strokes, color
FROM hole
LEFT JOIN round ON hole.round_id = round.id
WHERE round.tournament_id = $1
AND round.first_round = TRUE
AND hole_number = $2
GROUP BY color
ORDER BY strokes DESC
LIMIT 1
`

type GetMostCommonHoleForNumberParams struct {
	TournamentID int32
	HoleNumber   int32
}

type GetMostCommonHoleForNumberRow struct {
	Strokes int64
	Color   string
}

func (q *Queries) GetMostCommonHoleForNumber(ctx context.Context, arg GetMostCommonHoleForNumberParams) (GetMostCommonHoleForNumberRow, error) {
	row := q.db.QueryRowContext(ctx, getMostCommonHoleForNumber, arg.TournamentID, arg.HoleNumber)
	var i GetMostCommonHoleForNumberRow
	err := row.Scan(&i.Strokes, &i.Color)
	return i, err
}

const getStandardDeviation = `-- name: GetStandardDeviation :many
SELECT player_id, round(stddev(total_strokes), 3) as standard_deviation
FROM round
WHERE inserted_by = 'parser'
AND first_round = 't'
GROUP BY player_id
ORDER BY standard_deviation
`

type GetStandardDeviationRow struct {
	PlayerID          int64
	StandardDeviation string
}

// Stats
func (q *Queries) GetStandardDeviation(ctx context.Context) ([]GetStandardDeviationRow, error) {
	rows, err := q.db.QueryContext(ctx, getStandardDeviation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStandardDeviationRow
	for rows.Next() {
		var i GetStandardDeviationRow
		if err := rows.Scan(&i.PlayerID, &i.StandardDeviation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorstRounds = `-- name: GetWorstRounds :many
SELECT CAST(MAX(total_strokes) AS INTEGER) AS total_strokes, player_id
FROM round
WHERE tournament_id = $1
AND first_round = TRUE
GROUP BY player_id
ORDER BY total_strokes DESC
`

type GetWorstRoundsRow struct {
	TotalStrokes int32
	PlayerID     int64
}

// Stats queries
func (q *Queries) GetWorstRounds(ctx context.Context, tournamentID int32) ([]GetWorstRoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorstRounds, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorstRoundsRow
	for rows.Next() {
		var i GetWorstRoundsRow
		if err := rows.Scan(&i.TotalStrokes, &i.PlayerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
